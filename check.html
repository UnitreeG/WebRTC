<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot WebRTC Connection Check</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            color: #31708f;
            background-color: #d9edf7;
            border: 1px solid #bce8f1;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .error {
            padding: 10px;
            margin-top: 10px;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 4px;
            border: 1px solid #ffeeba;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #log {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }
        #errors {
            margin-top: 20px;
            padding: 10px;
            background-color: #ffeeee;
            border-radius: 4px;
            color: #721c24;
            font-family: monospace;
            display: none;
        }
        #robotInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 4px;
            display: none;
        }
        .connection-options {
            margin-top: 15px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        .mode-toggle {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        .mode-toggle label {
            cursor: pointer;
        }
        .sta-options input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 200px;
        }
    </style>
</head>
<body>
    <div id="serverDownload" style="margin: 20px auto; max-width: 600px; padding: 15px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #ddd;">
        <h3>WebRTC Signaling Server</h3>
        <p>To connect to the robot, you need to run the PeerJS signaling server:</p>
        <ol>
            <li>Download the PeerJS server executable for your platform:
                <ul>
                    <li><a href="https://github.com/UnitreeG/WebRTC/releases/download/v1.0.0/peer-win.exe" download>Windows Server (peer-win.exe)</a></li>
                    <li><a href="https://github.com/UnitreeG/WebRTC/releases/download/v1.0.0/peer-macos" download>MacOS Server (peer-macos)</a></li>
                    <li><a href="https://github.com/UnitreeG/WebRTC/releases/download/v1.0.0/peer-linux" download>Linux Server (peer-linux)</a></li>
                </ul>
            </li>
            <li>After downloading, run the executable with port 3478:
                <ul>
                    <li id="windows-instructions" style="display: none;">Double-click the .exe file or run <code><span id="win-cmd-name">peer.exe</span> --port 3478</code> in Command Prompt</li>
                    <li id="macos-instructions" style="display: none;">First make the file executable with <code>chmod +x <span id="mac-cmd-name">peer-macos</span></code> then run <code>./<span id="mac-cmd-name2">peer-macos</span> --port 3478</code></li>
                    <li id="linux-instructions" style="display: none;">First make the file executable with <code>chmod +x <span id="linux-cmd-name">peer-linux</span></code> then run <code>./<span id="linux-cmd-name2">peer-linux</span> --port 3478</code></li>
                </ul>
            </li>
            <li>Keep the server running in the background while using this page</li>
            <li>When the server is running successfully, you'll see a message like "PeerJS server started on port 3478"</li>
            <li>Click "Check Connection" below to connect to your robot</li>
        </ol>
    </div>

    <div class="container">
        <h1>Robot WebRTC Connection Check</h1>
        
        <div class="alert">
            <strong>Instructions:</strong> 
            <ol>
                <li>Make sure the robot is powered on</li>
                <li>Connect to the robot's WiFi network (usually named "GO2-XXXXXX")</li>
                <li>Click the "Check Connection" button below</li>
            </ol>
        </div>
        
        <div id="status" class="status disconnected">Status: Disconnected</div>
        
        <div class="connection-options">
            <div class="mode-toggle">
                <label>
                    <input type="radio" name="connection-mode" value="ap" checked> AP Mode (Direct Connection)
                </label>
                <label>
                    <input type="radio" name="connection-mode" value="sta"> STA Mode (Network Connection)
                </label>
            </div>
            <div class="sta-options" style="display: none; margin-top: 10px;">
                <label>Robot IP:
                    <input type="text" id="robotIpInput" value="192.168.8.181" placeholder="192.168.8.181">
                </label>
            </div>
            <button id="checkBtn">Check Connection</button>
        </div>
        
        <div id="errors"></div>
        <div id="robotInfo"></div>
        <div id="log"></div>
        
        <div id="securityToken" style="margin-top: 20px; padding: 15px; background-color: #fff8dc; border-radius: 5px; border: 1px solid #ffe4b5;">
            <h3>About Security Tokens</h3>
            <p><strong>Note:</strong> Connecting without a security token is possible and may work for a single connection. However, to use multiple clients simultaneously (like this page and the phone app), you'll need a valid security token.</p>
            
            <details>
                <summary><strong>How to obtain a security token</strong> (click to expand)</summary>
                <div style="padding: 10px; margin-top: 10px; background-color: #f9f9f9; border-radius: 4px;">
                    <p>The easiest way is to capture network traffic between the robot and your phone:</p>
                    <ol>
                        <li>Run an HTTP proxy (like tinyproxy) on your computer</li>
                        <li>Set your computer's IP and port as HTTP proxy on your phone</li>
                        <li>Use a network sniffer like Wireshark or ngrep to capture traffic on port 8081</li>
                        <li>Connect your phone to the robot via the official app</li>
                        <li>Look for the token in the captured network traffic</li>
                    </ol>
                    <p>The token appears in request payloads like this:</p>
                    <pre style="background-color: #f0f0f0; padding: 10px; border-radius: 4px; overflow-x: auto;">
{
    "token": "eyJ0eXAiOizI1NiJtlbiI[..]CI6MTcwODAxMzUwOX0.hiWOd9tNCIPzOOLNA",
    "sdp": "v=0\r\no=- ",
    "id": "STA_localNetwork",
    "type": "offer"
}
                    </pre>
                </div>
            </details>
        </div>
    </div>

    <script>
        let peerConnection = null;
        let dataChannel = null;
        
        // Set up error handlers to capture console errors
        window.addEventListener('error', function(event) {
            logError(`Error: ${event.message} at ${event.filename}:${event.lineno}`);
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            logError(`Unhandled Promise Rejection: ${event.reason}`);
        });
        
        // Override console methods to capture logs
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        console.log = function() {
            log(Array.from(arguments).join(' '));
            originalConsoleLog.apply(console, arguments);
        };
        
        console.error = function() {
            logError(Array.from(arguments).join(' '));
            originalConsoleError.apply(console, arguments);
        };
        
        console.warn = function() {
            logError(Array.from(arguments).join(' '), 'warn');
            originalConsoleWarn.apply(console, arguments);
        };
        
        // Function to log errors
        function logError(message, type = 'error') {
            const errorsDiv = document.getElementById('errors');
            const timestamp = new Date().toLocaleTimeString();
            
            // Create error message element
            const errorElement = document.createElement('div');
            errorElement.className = 'error';
            errorElement.innerHTML = `<strong>${timestamp}:</strong> ${message}`;
            
            // Add error to errors div
            errorsDiv.appendChild(errorElement);
            errorsDiv.style.display = 'block';
            
            // Also log to the regular log
            log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Function to log messages
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `${timestamp} - ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            
            // Add to stored logs for GitHub reporting
            if (window.connectionLogs === undefined) {
                window.connectionLogs = [];
            }
            window.connectionLogs.push(`${timestamp} - ${message}`);
        }
        
        // Make the log function available globally
        window.logMessage = log;
        
        // Update connection status display
        function setConnected(connected) {
            const status = document.getElementById('status');
            const checkBtn = document.getElementById('checkBtn');
            
            status.className = connected ? 'status connected' : 'status disconnected';
            status.textContent = `Status: ${connected ? 'Connected' : 'Disconnected'}`;
            checkBtn.disabled = connected;
        }
        
        // Update UI based on connection mode selection
        document.querySelectorAll('input[name="connection-mode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const staOptions = document.querySelector('.sta-options');
                if (this.value === 'sta') {
                    staOptions.style.display = 'block';
                } else {
                    staOptions.style.display = 'none';
                }
            });
        });
        
        // WebRTC connection setup
        async function connect() {
            try {
                // Get selected connection mode
                const mode = document.querySelector('input[name="connection-mode"]:checked').value;
                const robotIP = mode === 'ap' ? '192.168.8.1' : document.getElementById('robotIpInput').value;
                
                log(`Initializing WebRTC connection in ${mode.toUpperCase()} mode to robot at ${robotIP}...`);
                
                // Create peer connection
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                    sdpSemantics: "unified-plan"
                });
                
                // Add ICE connection state change listener
                peerConnection.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${peerConnection.iceConnectionState}`);
                    if (peerConnection.iceConnectionState === 'failed' || 
                        peerConnection.iceConnectionState === 'disconnected' || 
                        peerConnection.iceConnectionState === 'closed') {
                        logError(`ICE connection ${peerConnection.iceConnectionState}`);
                        
                        // If AP mode failed, try STA mode automatically
                        if (mode === 'ap' && peerConnection.iceConnectionState === 'failed') {
                            log('AP mode connection failed. Will try STA mode...');
                            
                            // Clean up current connection
                            if (dataChannel) {
                                dataChannel.close();
                                dataChannel = null;
                            }
                            if (peerConnection) {
                                peerConnection.close();
                                peerConnection = null;
                            }
                            
                            // Switch to STA mode
                            document.querySelector('input[value="sta"]').checked = true;
                            document.querySelector('.sta-options').style.display = 'block';
                            
                            // Wait a moment before retrying
                            setTimeout(() => {
                                log('Retrying connection in STA mode...');
                                connect();
                            }, 1000);
                        }
                    }
                };
                
                // Add signaling state change listener
                peerConnection.onsignalingstatechange = () => {
                    log(`Signaling state: ${peerConnection.signalingState}`);
                };
                
                // Log ICE candidates for debugging
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        log(`ICE candidate: ${JSON.stringify(event.candidate)}`);
                    } else {
                        log('ICE gathering complete');
                    }
                };
                
                // Add ICE candidate error handler
                peerConnection.onicecandidateerror = (event) => {
                    logError(`ICE candidate error: ${event.errorText} (${event.errorCode})`);
                };
                
                // Create data channel
                dataChannel = peerConnection.createDataChannel("data");
                setupDataChannel();
                
                // Add transceivers for audio and video
                peerConnection.addTransceiver("video", { direction: "recvonly" });
                peerConnection.addTransceiver("audio", { direction: "sendrecv" });
                
                // Create and set local description (offer)
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('Offer created');
                log(`SDP offer details: ${offer.sdp}`);
                
                // Try all possible connection methods
                try {
                    // First try direct connection to robot
                    log(`Attempting direct connection to robot at ${robotIP}`);
                    
                    const directAnswer = {
                        token: "direct-connection",
                        id: mode === 'ap' ? "AP_direct" : "STA_localNetwork",
                        type: "offer",
                        ip: robotIP,
                        sdp: peerConnection.localDescription.sdp
                    };
                    
                    log(`Sending offer directly to robot at ${robotIP} (${mode.toUpperCase()} mode)`);
                    log(`Connection ID: "${directAnswer.id}"`);
                    log(`Token used: "direct-connection"`);
                    
                    // Try different ports and endpoints that might be used by the robot
                    const directEndpoints = [
                        { port: 8081, path: '/offer' },
                        { port: 8080, path: '/webrtc/offer' },
                        { port: 80, path: '/webrtc/offer' },
                        { port: 443, path: '/webrtc/offer' }
                    ];
                    
                    let directSuccess = false;
                    let directError = null;
                    
                    for (const endpoint of directEndpoints) {
                        try {
                            log(`Trying direct connection to http://${robotIP}:${endpoint.port}${endpoint.path}`);
                            
                            const directResponse = await fetch(`http://${robotIP}:${endpoint.port}${endpoint.path}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(directAnswer),
                                // Short timeout to fail fast
                                signal: AbortSignal.timeout(3000)
                            });
                            
                            if (!directResponse.ok) {
                                throw new Error(`Direct connection failed with status: ${directResponse.status}`);
                            }
                            
                            const directData = await directResponse.json();
                            log('Received answer directly from robot');
                            log(`SDP answer details: ${directData.sdp}`);
                            
                            // Set remote description from answer
                            await peerConnection.setRemoteDescription(directData);
                            log(`WebRTC connection established through direct signaling on port ${endpoint.port}`);
                            
                            directSuccess = true;
                            setConnected(true);
                            startHeartbeat();
                            setTimeout(requestRobotInfo, 2000);
                            break;
                        } catch (err) {
                            log(`Failed on endpoint ${endpoint.port}${endpoint.path}: ${err.message}`);
                            directError = err;
                        }
                    }
                    
                    if (directSuccess) {
                        return; // Exit if direct connection was successful
                    }
                    
                    // If direct connection fails, try through local signaling server
                    log('Direct connection methods failed. Trying local signaling server...');
                    
                    const serverAnswer = {
                        token: "direct-connection",
                        id: mode === 'ap' ? "AP_direct" : "STA_localNetwork",
                        type: "offer",
                        ip: robotIP,
                        sdp: peerConnection.localDescription.sdp
                    };
                    
                    // Try signaling servers on different ports
                    const signalingPorts = [3478, 8081, 9991];
                    let signalingSuccess = false;
                    
                    for (const port of signalingPorts) {
                        try {
                            log(`Trying signaling server at port ${port}`);
                            
                            const serverResponse = await fetch(`http://${window.location.hostname}:${port}/offer`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(serverAnswer),
                                signal: AbortSignal.timeout(3000)
                            });
                            
                            if (!serverResponse.ok) {
                                throw new Error(`Signaling server on port ${port} failed with status: ${serverResponse.status}`);
                            }
                            
                            const serverData = await serverResponse.json();
                            log(`Received answer from signaling server on port ${port}`);
                            log(`SDP answer details: ${serverData.sdp}`);
                            
                            // Set remote description from answer
                            await peerConnection.setRemoteDescription(serverData);
                            log(`WebRTC connection established via signaling server on port ${port}`);
                            
                            signalingSuccess = true;
                            setConnected(true);
                            startHeartbeat();
                            
                            // Request robot information after connection
                            setTimeout(requestRobotInfo, 2000);
                            break; // Exit loop if successful
                        } catch (err) {
                            log(`Failed on signaling server port ${port}: ${err.message}`);
                        }
                    }
                    
                    if (!signalingSuccess) {
                        throw new Error("All signaling server attempts failed");
                    }
                    
                } catch (error) {
                    throw new Error(`All connection methods failed: ${error.message}`);
                }
                
            } catch (error) {
                logError(`Connection failed: ${error.message}`);
                setConnected(false);
                
                // Clean up
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
            }
        }
        
        // Set up data channel event handlers
        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened');
            };
            
            dataChannel.onclose = () => {
                log('Data channel closed');
                setConnected(false);
            };
            
            dataChannel.onerror = (error) => {
                logError(`Data channel error: ${error}`);
            };
            
            dataChannel.onmessage = (event) => {
                if (event.data && event.data.includes && !event.data.includes("heartbeat")) {
                    log(`Received message: ${event.data}`);
                    handleMessage(event.data);
                }
            };
        }
        
        // Handle incoming messages
        function handleMessage(message) {
            try {
                const data = JSON.parse(message);
                
                // Log the entire message for debugging
                logError(`Complete message received: ${JSON.stringify(data)}`, 'debug');
                
                // Handle validation message
                if (data.type === "VALIDATION") {
                    if (data.data === "Validation Ok.") {
                        log("Validation successful");
                    } else {
                        const validationKey = data.data;
                        log(`Received validation challenge: ${validationKey}`);
                        // Encrypt the validation key using MD5
                        const encryptedKey = md5(validationKey);
                        log(`Encrypted validation key (MD5): ${encryptedKey}`);
                        publishMessage("", encryptedKey, "VALIDATION");
                    }
                }
                
                // Handle robot info message
                if (data.type === "MSG" && data.data && data.data.header) {
                    const statusCode = data.data.header.status?.code;
                    const apiId = data.data.header?.identity?.api_id;
                    
                    log(`Received response for API ID: ${apiId}, status code: ${statusCode}`);
                    
                    if (statusCode === 0) {
                        displayRobotInfo(data);
                    } else if (statusCode !== undefined) {
                        logError(`API error: Status code ${statusCode} for API ID ${apiId}`);
                    }
                }
                
            } catch (error) {
                logError(`Error handling message: ${error.message}`);
            }
        }
        
        // Display robot information
        function displayRobotInfo(data) {
            try {
                const infoDiv = document.getElementById('robotInfo');
                
                if (data.data && data.data.data) {
                    let robotData;
                    
                    // Handle string or object data
                    if (typeof data.data.data === 'string') {
                        robotData = JSON.parse(data.data.data);
                    } else {
                        robotData = data.data.data;
                    }
                    
                    // Create HTML content with robot information
                    let infoHTML = '<h3>Robot Information</h3>';
                    infoHTML += '<table style="width:100%">';
                    
                    // Add all available information
                    for (const [key, value] of Object.entries(robotData)) {
                        infoHTML += `<tr><td><strong>${key}</strong></td><td>${value}</td></tr>`;
                    }
                    
                    infoHTML += '</table>';
                    
                    // Update display
                    infoDiv.innerHTML = infoHTML;
                    infoDiv.style.display = 'block';
                }
            } catch (error) {
                logError(`Error displaying robot info: ${error.message}`);
            }
        }
        
        // Request robot information
        function requestRobotInfo() {
            try {
                // Request robot system information
                publishApi("SPORT", 3, {});  // System info API
                
                // Also request battery information
                publishApi("SPORT", 4, {});  // Battery info API
            } catch (error) {
                logError(`Error requesting robot info: ${error.message}`);
            }
        }
        
        // Start heartbeat to keep connection alive
        function startHeartbeat() {
            window.setInterval(() => {
                try {
                    if (dataChannel && dataChannel.readyState === "open") {
                        const date = new Date();
                        const heartbeatMsg = {
                            type: "HEARTBEAT",
                            data: {
                                timeInStr: formatDate(date),
                                timeInNum: Math.floor(date.valueOf() / 1000),
                            },
                        };
                        dataChannel.send(JSON.stringify(heartbeatMsg));
                    }
                } catch (error) {
                    logError(`Heartbeat error: ${error.message}`);
                }
            }, 2000);
        }
        
        // Format date for heartbeat
        function formatDate(date) {
            const y = date.getFullYear();
            const m = ("0" + (date.getMonth() + 1)).slice(-2);
            const d = ("0" + date.getDate()).slice(-2);
            const hh = ("0" + date.getHours()).slice(-2);
            const mm = ("0" + date.getMinutes()).slice(-2);
            const ss = ("0" + date.getSeconds()).slice(-2);
            return y + "-" + m + "-" + d + " " + hh + ":" + mm + ":" + ss;
        }
        
        // Publish message to data channel
        function publishMessage(topic, data, channelType) {
            try {
                if (dataChannel && dataChannel.readyState === "open") {
                    const msg = {
                        type: channelType,
                        topic: topic,
                        data: data,
                    };
                    
                    // Log messages with different levels of detail based on type
                    if (channelType === "VALIDATION") {
                        log(`Sending validation response: ${JSON.stringify(msg)}`);
                    } else if (channelType === "HEARTBEAT") {
                        // Don't log heartbeats to avoid cluttering the log
                    } else {
                        log(`Sending message: ${JSON.stringify(msg)}`);
                    }
                    
                    dataChannel.send(JSON.stringify(msg));
                    return true;
                }
                return false;
            } catch (error) {
                logError(`Error publishing message: ${error.message}`);
                return false;
            }
        }
        
        // Publish API command
        function publishApi(topic, api_id, data) {
            try {
                const uniqID = (new Date().valueOf() % 2147483648) + Math.floor(Math.random() * 1000);
                
                const msg = {
                    header: { 
                        identity: { 
                            id: uniqID, 
                            api_id: api_id 
                        } 
                    },
                    parameter: data
                };
                
                return publishMessage(topic, msg, "MSG");
            } catch (error) {
                logError(`Error in publishApi: ${error.message}`);
                return false;
            }
        }
        
        // MD5 function for validation
        function md5(string) {
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }

            function ff(a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }

            function gg(a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }

            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }

            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            }

            function md5cycle(x, k) {
                let a = x[0], b = x[1], c = x[2], d = x[3];

                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);

                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);

                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);

                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);

                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }

            function md5blk(s) {
                let i, md5blks = [];
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }

            function md5blk_array(a) {
                let i, md5blks = [];
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                }
                return md5blks;
            }

            function md51(s) {
                let n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i;
                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < s.length; i++) {
                    tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                }
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i++) tail[i] = 0;
                }
                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }

            function add32(a, b) {
                return (a + b) & 0xFFFFFFFF;
            }

            function hex_md5(s) {
                let result = "";
                let state = md51(s);
                for (let i = 0; i < 4; i++) {
                    result += hex_chr[(state[i] >> 0) & 0xF] + hex_chr[(state[i] >> 4) & 0xF] +
                        hex_chr[(state[i] >> 8) & 0xF] + hex_chr[(state[i] >> 12) & 0xF] +
                        hex_chr[(state[i] >> 16) & 0xF] + hex_chr[(state[i] >> 20) & 0xF] +
                        hex_chr[(state[i] >> 24) & 0xF] + hex_chr[(state[i] >> 28) & 0xF];
                }
                return result;
            }

            const hex_chr = '0123456789abcdef'.split('');
            return hex_md5(string);
        }
        
        // Event listeners
        document.getElementById('checkBtn').addEventListener('click', connect);
    </script>
</body>
</html> 