<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot WebRTC Connection Check</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            color: #31708f;
            background-color: #d9edf7;
            border: 1px solid #bce8f1;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .error {
            padding: 10px;
            margin-top: 10px;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 4px;
            border: 1px solid #ffeeba;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #log {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }
        #errors {
            margin-top: 20px;
            padding: 10px;
            background-color: #ffeeee;
            border-radius: 4px;
            color: #721c24;
            font-family: monospace;
            display: none;
        }
        #robotInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Robot WebRTC Connection Check</h1>
        
        <div class="alert">
            <strong>Instructions:</strong> 
            <ol>
                <li>Make sure the robot is powered on</li>
                <li>Connect to the robot's WiFi network (usually named "GO2-XXXXXX")</li>
                <li>Click the "Check Connection" button below</li>
            </ol>
        </div>
        
        <div id="status" class="status disconnected">Status: Disconnected</div>
        
        <div>
            <button id="checkBtn">Check Connection</button>
        </div>
        
        <div id="errors"></div>
        <div id="robotInfo"></div>
        <div id="log"></div>
    </div>

    <script>
        let peerConnection = null;
        let dataChannel = null;
        
        // Set up error handlers to capture console errors
        window.addEventListener('error', function(event) {
            logError(`Error: ${event.message} at ${event.filename}:${event.lineno}`);
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            logError(`Unhandled Promise Rejection: ${event.reason}`);
        });
        
        // Override console methods to capture logs
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        console.log = function() {
            log(Array.from(arguments).join(' '));
            originalConsoleLog.apply(console, arguments);
        };
        
        console.error = function() {
            logError(Array.from(arguments).join(' '));
            originalConsoleError.apply(console, arguments);
        };
        
        console.warn = function() {
            logError(Array.from(arguments).join(' '), 'warn');
            originalConsoleWarn.apply(console, arguments);
        };
        
        // Function to log errors
        function logError(message, type = 'error') {
            const errorsDiv = document.getElementById('errors');
            const timestamp = new Date().toLocaleTimeString();
            
            // Create error message element
            const errorElement = document.createElement('div');
            errorElement.className = 'error';
            errorElement.innerHTML = `<strong>${timestamp}:</strong> ${message}`;
            
            // Add error to errors div
            errorsDiv.appendChild(errorElement);
            errorsDiv.style.display = 'block';
            
            // Also log to the regular log
            log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Function to log messages
        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += `${new Date().toLocaleTimeString()} - ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        // Make the log function available globally
        window.logMessage = log;
        
        // Update connection status display
        function setConnected(connected) {
            const status = document.getElementById('status');
            const checkBtn = document.getElementById('checkBtn');
            
            status.className = connected ? 'status connected' : 'status disconnected';
            status.textContent = `Status: ${connected ? 'Connected' : 'Disconnected'}`;
            checkBtn.disabled = connected;
        }
        
        // WebRTC connection setup
        async function connect() {
            try {
                log('Initializing WebRTC connection...');
                
                // Create peer connection
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                    sdpSemantics: "unified-plan"
                });
                
                // Add ICE connection state change listener
                peerConnection.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${peerConnection.iceConnectionState}`);
                    if (peerConnection.iceConnectionState === 'failed' || 
                        peerConnection.iceConnectionState === 'disconnected' || 
                        peerConnection.iceConnectionState === 'closed') {
                        logError(`ICE connection ${peerConnection.iceConnectionState}`);
                    }
                };
                
                // Add signaling state change listener
                peerConnection.onsignalingstatechange = () => {
                    log(`Signaling state: ${peerConnection.signalingState}`);
                };
                
                // Add ICE candidate error handler
                peerConnection.onicecandidateerror = (event) => {
                    logError(`ICE candidate error: ${event.errorText} (${event.errorCode})`);
                };
                
                // Create data channel
                dataChannel = peerConnection.createDataChannel("data");
                setupDataChannel();
                
                // Add transceivers for audio and video
                peerConnection.addTransceiver("video", { direction: "recvonly" });
                peerConnection.addTransceiver("audio", { direction: "sendrecv" });
                
                // Create and set local description (offer)
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('Offer created');
                
                // Send offer to robot via signaling server
                // For AP mode, we use the default IP 192.168.8.1
                const robotIP = '192.168.8.1';
                
                const answer = {
                    token: "direct-connection",
                    id: "STA_localNetwork",
                    type: "offer",
                    ip: robotIP,
                    sdp: peerConnection.localDescription.sdp
                };
                
                log(`Sending offer to robot at ${robotIP}`);
                
                // Send offer through local signaling server
                // Note: In production, ensure proper signaling server is running
                const response = await fetch(`http://${window.location.hostname}:8081/offer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(answer),
                });
                
                if (!response.ok) {
                    throw new Error(`Signaling failed with status: ${response.status}`);
                }
                
                const data = await response.json();
                log('Received answer from signaling server');
                
                // Set remote description from answer
                await peerConnection.setRemoteDescription(data);
                log('WebRTC connection established');
                
                setConnected(true);
                startHeartbeat();
                
                // Request robot information after connection
                setTimeout(requestRobotInfo, 2000);
                
            } catch (error) {
                logError(`Connection failed: ${error.message}`);
                setConnected(false);
                
                // Clean up
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
            }
        }
        
        // Set up data channel event handlers
        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened');
            };
            
            dataChannel.onclose = () => {
                log('Data channel closed');
                setConnected(false);
            };
            
            dataChannel.onerror = (error) => {
                logError(`Data channel error: ${error}`);
            };
            
            dataChannel.onmessage = (event) => {
                if (event.data && event.data.includes && !event.data.includes("heartbeat")) {
                    log(`Received message: ${event.data}`);
                    handleMessage(event.data);
                }
            };
        }
        
        // Handle incoming messages
        function handleMessage(message) {
            try {
                const data = JSON.parse(message);
                
                // Handle validation message
                if (data.type === "VALIDATION") {
                    if (data.data === "Validation Ok.") {
                        log("Validation successful");
                    } else {
                        log(`Sending validation key: ${data.data}`);
                        // Encrypt the validation key using MD5
                        const encryptedKey = md5(data.data);
                        publishMessage("", encryptedKey, "VALIDATION");
                    }
                }
                
                // Handle robot info message
                if (data.type === "MSG" && data.data && data.data.header) {
                    const statusCode = data.data.header.status?.code;
                    if (statusCode === 0) {
                        displayRobotInfo(data);
                    } else if (statusCode !== undefined) {
                        logError(`API error: Status code ${statusCode}`);
                    }
                }
                
            } catch (error) {
                logError(`Error handling message: ${error.message}`);
            }
        }
        
        // Display robot information
        function displayRobotInfo(data) {
            try {
                const infoDiv = document.getElementById('robotInfo');
                
                if (data.data && data.data.data) {
                    let robotData;
                    
                    // Handle string or object data
                    if (typeof data.data.data === 'string') {
                        robotData = JSON.parse(data.data.data);
                    } else {
                        robotData = data.data.data;
                    }
                    
                    // Create HTML content with robot information
                    let infoHTML = '<h3>Robot Information</h3>';
                    infoHTML += '<table style="width:100%">';
                    
                    // Add all available information
                    for (const [key, value] of Object.entries(robotData)) {
                        infoHTML += `<tr><td><strong>${key}</strong></td><td>${value}</td></tr>`;
                    }
                    
                    infoHTML += '</table>';
                    
                    // Update display
                    infoDiv.innerHTML = infoHTML;
                    infoDiv.style.display = 'block';
                }
            } catch (error) {
                logError(`Error displaying robot info: ${error.message}`);
            }
        }
        
        // Request robot information
        function requestRobotInfo() {
            try {
                // Request robot system information
                publishApi("SPORT", 3, {});  // System info API
                
                // Also request battery information
                publishApi("SPORT", 4, {});  // Battery info API
            } catch (error) {
                logError(`Error requesting robot info: ${error.message}`);
            }
        }
        
        // Start heartbeat to keep connection alive
        function startHeartbeat() {
            window.setInterval(() => {
                try {
                    if (dataChannel && dataChannel.readyState === "open") {
                        const date = new Date();
                        const heartbeatMsg = {
                            type: "HEARTBEAT",
                            data: {
                                timeInStr: formatDate(date),
                                timeInNum: Math.floor(date.valueOf() / 1000),
                            },
                        };
                        dataChannel.send(JSON.stringify(heartbeatMsg));
                    }
                } catch (error) {
                    logError(`Heartbeat error: ${error.message}`);
                }
            }, 2000);
        }
        
        // Format date for heartbeat
        function formatDate(date) {
            const y = date.getFullYear();
            const m = ("0" + (date.getMonth() + 1)).slice(-2);
            const d = ("0" + date.getDate()).slice(-2);
            const hh = ("0" + date.getHours()).slice(-2);
            const mm = ("0" + date.getMinutes()).slice(-2);
            const ss = ("0" + date.getSeconds()).slice(-2);
            return y + "-" + m + "-" + d + " " + hh + ":" + mm + ":" + ss;
        }
        
        // Publish message to data channel
        function publishMessage(topic, data, channelType) {
            try {
                if (dataChannel && dataChannel.readyState === "open") {
                    const msg = {
                        type: channelType,
                        topic: topic,
                        data: data,
                    };
                    log(`Sending message: ${JSON.stringify(msg)}`);
                    dataChannel.send(JSON.stringify(msg));
                    return true;
                }
                return false;
            } catch (error) {
                logError(`Error publishing message: ${error.message}`);
                return false;
            }
        }
        
        // Publish API command
        function publishApi(topic, api_id, data) {
            try {
                const uniqID = (new Date().valueOf() % 2147483648) + Math.floor(Math.random() * 1000);
                
                const msg = {
                    header: { 
                        identity: { 
                            id: uniqID, 
                            api_id: api_id 
                        } 
                    },
                    parameter: data
                };
                
                return publishMessage(topic, msg, "MSG");
            } catch (error) {
                logError(`Error in publishApi: ${error.message}`);
                return false;
            }
        }
        
        // MD5 function for validation
        function md5(string) {
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }

            function ff(a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }

            function gg(a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }

            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }

            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            }

            function md5cycle(x, k) {
                let a = x[0], b = x[1], c = x[2], d = x[3];

                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);

                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);

                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);

                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);

                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }

            function md5blk(s) {
                let i, md5blks = [];
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }

            function md5blk_array(a) {
                let i, md5blks = [];
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                }
                return md5blks;
            }

            function md51(s) {
                let n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i;
                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                let tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < s.length; i++) {
                    tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                }
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i++) tail[i] = 0;
                }
                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }

            function add32(a, b) {
                return (a + b) & 0xFFFFFFFF;
            }

            function hex_md5(s) {
                let result = "";
                let state = md51(s);
                for (let i = 0; i < 4; i++) {
                    result += hex_chr[(state[i] >> 0) & 0xF] + hex_chr[(state[i] >> 4) & 0xF] +
                        hex_chr[(state[i] >> 8) & 0xF] + hex_chr[(state[i] >> 12) & 0xF] +
                        hex_chr[(state[i] >> 16) & 0xF] + hex_chr[(state[i] >> 20) & 0xF] +
                        hex_chr[(state[i] >> 24) & 0xF] + hex_chr[(state[i] >> 28) & 0xF];
                }
                return result;
            }

            const hex_chr = '0123456789abcdef'.split('');
            return hex_md5(string);
        }
        
        // Event listeners
        document.getElementById('checkBtn').addEventListener('click', connect);
    </script>
</body>
</html> 